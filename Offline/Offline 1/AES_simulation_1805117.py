# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""

# !pip install BitVector


"""Tables"""
import time
import math
import sys
import binascii
from BitVector import *
Sbox = (
    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,
)

InvSbox = (
    0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D,
)

Mixer = [
    [BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03"), BitVector(hexstring="01")],
    [BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02"), BitVector(hexstring="03")],
    [BitVector(hexstring="03"), BitVector(hexstring="01"), BitVector(hexstring="01"), BitVector(hexstring="02")]
]

InvMixer = [
    [BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09")],
    [BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B"), BitVector(hexstring="0D")],
    [BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E"), BitVector(hexstring="0B")],
    [BitVector(hexstring="0B"), BitVector(hexstring="0D"), BitVector(hexstring="09"), BitVector(hexstring="0E")]
]

aes_len = 128
round = 10
aes_key = ''
AES_modulus = BitVector(bitstring='100011011')

def AES(key):
    key_words = []
    key_bv = process_key(key)
    if aes_len == 128:    
        key_words = gen_key_schedule_128(key_bv)
    elif aes_len == 192:    
        key_words = gen_key_schedule_192(key_bv)
    elif aes_len == 256:    
        key_words = gen_key_schedule_256(key_bv)
    else:
        sys.exit("wrong keysize --- aborting")
    
    key_schedule = []
    # print("\nEach 32-bit word of the key schedule is shown as a sequence of 4 one-byte integers:")
    for word_index,word in enumerate(key_words):
        keyword_in_ints = []
        for i in range(4):
            keyword_in_ints.append(word[i*8:i*8+8].intValue())
        # if word_index % 4 == 0: print("\n")
        # print("word %d:  %s" % (word_index, str(keyword_in_ints)))
        key_schedule.append(keyword_in_ints)
    if aes_len == 128: round = 10
    if aes_len == 192: round = 12
    if aes_len == 256: round = 14
    round_keys = [None for i in range(round+1)]
    for i in range(round+1):
        round_keys[i] = (key_words[i*4] + key_words[i*4+1] + key_words[i*4+2] + 
                                                       key_words[i*4+3])
    # print("\n\nRound keys in hex (first key for input block):\n")
    # for round_key in round_keys:
    #     print(round_key)
    return round_keys
    

def gee(keyword, round_constant):
    '''
    This is the g() function you see in Figure 4 of Lecture 8.
    '''
    rotated_word = keyword.deep_copy()
    rotated_word << 8
    newword = BitVector(size = 0)
    for i in range(4):
        newword += BitVector(intVal = Sbox[rotated_word[8*i:8*i+8].intValue()], size = 8)
    newword[:8] ^= round_constant
    round_constant = round_constant.gf_multiply_modular(BitVector(intVal = 0x02), AES_modulus, 8)
    # print('Type of newword', type(newword))
    return newword, round_constant

def gen_key_schedule_128(key_bv):
    #  We need 44 keywords in the key schedule for 128 bit AES.  Each keyword is 32-bits
    #  wide. The 128-bit AES uses the first four keywords to xor the input block with.
    #  Subsequently, each of the 10 rounds uses 4 keywords from the key schedule. We will
    #  store all 44 keywords in the following list:
    key_words = [BitVector(intVal = 0x00) for i in range(44)]
    
    round_constant = BitVector(intVal = 0x01, size=8)
    for i in range(4):
        key_words[i] = key_bv[i*32 : i*32 + 32]
    # print('key_words', type(key_words[0]))
    for i in range(4,44):
        if i%4 == 0:
            kwd, round_constant = gee(key_words[i-1], round_constant)
            key_words[i] = key_words[i-4] ^ kwd
        else:
            key_words[i] = key_words[i-4] ^ key_words[i-1]
    # print('key_words', type(key_words[0]))
    return key_words

def gen_key_schedule_192(key_bv):
    #  We need 52 keywords (each keyword consists of 32 bits) in the key schedule for
    #  192 bit AES.  The 192-bit AES uses the first four keywords to xor the input
    #  block with.  Subsequently, each of the 12 rounds uses 4 keywords from the key
    #  schedule. We will store all 52 keywords in the following list:
    key_words = [BitVector(intVal = 0x00) for i in range(52)]
    round_constant = BitVector(intVal = 0x01, size=8)
    for i in range(6):
        key_words[i] = key_bv[i*32 : i*32 + 32]
    for i in range(6,52):
        if i%6 == 0:
            kwd, round_constant = gee(key_words[i-1], round_constant)
            key_words[i] = key_words[i-6] ^ kwd
        else:
            key_words[i] = key_words[i-6] ^ key_words[i-1]
    return key_words

def gen_key_schedule_256(key_bv):
    #  We need 60 keywords (each keyword consists of 32 bits) in the key schedule for
    #  256 bit AES. The 256-bit AES uses the first four keywords to xor the input
    #  block with.  Subsequently, each of the 14 rounds uses 4 keywords from the key
    #  schedule. We will store all 60 keywords in the following list:
    key_words = [BitVector(intVal = 0x00) for i in range(60)]
    round_constant = BitVector(intVal = 0x01, size=8)
    for i in range(8):
        key_words[i] = key_bv[i*32 : i*32 + 32]
    for i in range(8,60):
        if i%8 == 0:
            kwd, round_constant = gee(key_words[i-1], round_constant)
            key_words[i] = key_words[i-8] ^ kwd
        elif (i - (i//8)*8) < 4:
            key_words[i] = key_words[i-8] ^ key_words[i-1]
        elif (i - (i//8)*8) == 4:
            key_words[i] = BitVector(size = 0)
            for j in range(4):
                key_words[i] += BitVector(intVal = 
                                 Sbox[key_words[i-1][8*j:8*j+8].intValue()], size = 8)
            key_words[i] ^= key_words[i-8] 
        elif ((i - (i//8)*8) > 4) and ((i - (i//8)*8) < 8):
            key_words[i] = key_words[i-8] ^ key_words[i-1]
        else:
            sys.exit("error in key scheduling algo for i = %d" % i)
    return key_words

def process_key(key):
    keysize = aes_len // 8
    key = key.strip()
    key = '0' * (keysize//8 - len(key)) if len(key) < keysize else key[:keysize]  
    key_bv = BitVector( textstring = key )
    return key_bv

# generate blocks of aes_len bits
def generateBlocks(text):
    blocks = []
    if len(text)*8 < aes_len :
        key_len = aes_len - len(text)*8
        text = "0"*math.floor(key_len/8) + text
    elif len(text)*8 > aes_len :
        number_of_blocks = len(text)*8/aes_len
        extra=0
        if number_of_blocks.is_integer():
            number_of_blocks = int(number_of_blocks)
        else :
            extra = number_of_blocks - math.floor(number_of_blocks)
            number_of_blocks = math.floor(number_of_blocks)
        # print("number_of_blocks",number_of_blocks)
        end=0
        for i in range(number_of_blocks):
            blocks.append(text[32*i:32*i+32])
            # print(blocks[-1])
            end = 32*i+32
        if extra!=0:
            blocks.append(text[end:])
            # print(blocks[-1])
    else :
        blocks = text
    return blocks

# circularly left shift a list by n
def leftShift(l, n):
    return l[n:] + l[:n]
# circularly right shift a list by n
def rightShift(l, n):   
    return l[-n:] + l[:-n]

# circularly left shift a matrix by n
def leftShiftMatrix(m):
    for i in range(len(m)):
        m[i] = leftShift(m[i], i)
    return m
# circularly right shift a matrix by n
def rightShiftMatrix(m):
    for i in range(len(m)):
        m[i] = rightShift(m[i], i)
    return m

# substitute bytes in a list
def subBytes(l):
    for i in range(len(l)):
        l[i] = BitVector(intVal=Sbox[l[i].intValue()], size=8)
    return l
# substitute bytes in a matrix
def subBytesMatrix(m):
    for i in range(len(m)):
        m[i] = subBytes(m[i])
    return m

# subsitute bytes in a list with InvSbox
def invSubBytes(l):
    for i in range(len(l)):
        l[i] = BitVector(intVal=InvSbox[l[i].intValue()], size=8)
    return l
# subsitute bytes in a matrix with InvSbox
def invSubBytesMatrix(m):
    for i in range(len(m)):
        m[i] = invSubBytes(m[i])
    return m

# xor two lists
def xor(l1, l2):
    for i in range(len(l1)):
        l1[i] = l1[i] ^ l2[i]
    return l1
# xor two matrices
def xorMatrix(m1, m2):
    for i in range(len(m1)):
        m1[i] = xor(m1[i], m2[i])
    return m1

# multiply two matrixes Mixer and m2
def multiplyMatrix(m2):
    m3 = [[BitVector(intVal=0, size=8) for i in range(len(m2[0]))] for j in range(len(Mixer))]
    for i in range(len(Mixer)):
        for j in range(len(m2[0])):
            for k in range(len(m2)):
                m3[i][j] ^= Mixer[i][k].gf_multiply_modular(m2[k][j], AES_modulus, 8)
    return m3

# multiply two matrixes InvMixer and m2
def invMultiplyMatrix(m2):
    m3 = [[BitVector(intVal=0, size=8) for i in range(len(m2[0]))] for j in range(len(InvMixer))]
    for i in range(len(InvMixer)):
        for j in range(len(m2[0])):
            for k in range(len(m2)):
                m3[i][j] ^= InvMixer[i][k].gf_multiply_modular(m2[k][j], AES_modulus, 8)
    return m3

# generate a 4x4 matrix from a 128-bit block
def generateMatrix(block):
    matrix = [[BitVector(intVal=0, size=8) for i in range(4)] for j in range(4)]
    for i in range(4):
        for j in range(4):
            matrix[i][j] = block[i*32+j*8:i*32+j*8+8]
    return matrix

# print a bitvector matrix
def printMatrix(matrix):
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            print(matrix[i][j].get_bitvector_in_hex(), end=" ")
        print()
# print a bitvector list
def printList(l):
    for i in range(len(l)):
        print(l[i].get_bitvector_in_hex(), end="")

# transpose a matrix
def transposeMatrix(matrix):
    for i in range(len(matrix)):
        for j in range(i+1, len(matrix[0])):
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
    return matrix
# convert a 2D matrix to a 1D list
def convert_2D_to_1D(matrix):
    result = []
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            result.append(matrix[i][j])
    return result

# convert ascii string to bit vector
def asciiToBitVector(plain_text):
    return BitVector(textstring=plain_text)

def hexToAscii(cipher_text):
    return cipher_text.get_bitvector_in_ascii()
# convert bit vector to hex
def bitVectorToHex(bit_vector):
    return bit_vector.get_hex_string_from_bitvector()

# convert a list of bitvector to hex
def matrixToBitVector(matrix):
    result = []
    for i in range(len(matrix)):
        result.append(matrix[i].get_bitvector_in_ascii())
    return result

# convert ascii string to hex
def asciiToHex(plain_text):
    return BitVector(textstring=plain_text).get_hex_string_from_bitvector()

def hexToAsciifromList(cipher_text):
    result = []
    for i in range(len(cipher_text)):
        result.append(cipher_text[i].get_bitvector_in_ascii())
    return result
# convert a 3D matrix into a string
def convert_to_string(matrix):
    result = ''
    for i in range(len(matrix)):
        for j in range(len(matrix[0])):
            for k in range(len(matrix[0][0])):
                result += matrix[i][j][k].get_bitvector_in_ascii()
    return result

def printArray(array):
    for i in range(len(array)):
        print(array[i], end="")

# encrypt a 128-bit block
def encryptBlock(block, roundKeys):
    keyMatrix = [generateMatrix(roundKeys[i]) for i in range(round+1)]
    block = generateMatrix(block)
    for i in range(round+1):
        keyMatrix[i] = transposeMatrix(keyMatrix[i])
    block = transposeMatrix(block)
    # printMatrix(block)
    # print()
    # printMatrix(keyMatrix[0])

    block = xorMatrix(block, keyMatrix[0])
    # 9 rounds
    for i in range(1, round):
        # substitute bytes
        block = subBytesMatrix(block)
        # shift rows
        block = leftShiftMatrix(block)
        # mix columns
        block = multiplyMatrix(block)
        # add round key
        block = xorMatrix(block, keyMatrix[i])
    # substitute bytes
    block = subBytesMatrix(block)
    # shift rows
    block = leftShiftMatrix(block)
    # add round key
    block = xorMatrix(block, keyMatrix[-1])
    return block

# decrypt a 128-bit block
def decryptBlock(block, roundKeys):
    keyMatrix = [generateMatrix(roundKeys[i]) for i in range(round+1)]
    block = generateMatrix(block)
    for i in range(round+1):
        keyMatrix[i] = transposeMatrix(keyMatrix[i])
    block = transposeMatrix(block)
    # print('printing block')
    # printMatrix(block)
    # print()
    # printMatrix(keyMatrix[0])
    # add round key
    block = xorMatrix(block, keyMatrix[-1])
    # 9 rounds
    for i in range(round-1, 0, -1):
        # shift rows
        block = rightShiftMatrix(block)
        # substitute bytes
        block = invSubBytesMatrix(block)
        # add round key
        block = xorMatrix(block, keyMatrix[i])
        # mix columns
        block = invMultiplyMatrix(block)
    # shift rows
    block = rightShiftMatrix(block)
    # substitute bytes
    block = invSubBytesMatrix(block)
    # add round key
    block = xorMatrix(block, keyMatrix[0])
    return block

# encrypt a plain text
def encrypt(plain_text, key):
    t1 = time.time()
    roundKeys = AES(key)
    t2 = time.time()
    print('Time taken to generate round keys: ', t2 - t1)
    # print('Plain_text: ',plain_text)
    while(len(plain_text) % (aes_len//8) != 0):
        plain_text += ' '
    # encrypt plain text
    cipher_text = []
    j=0
    # print('len of plain text:', len(plain_text))
    for i in range(0, len(plain_text), aes_len//8):
        # print('i: ', i)
        block = plain_text[i:i+aes_len//8]
        # convert plain text to bit vector
        block = asciiToBitVector(block)
        cipher_text.append(encryptBlock(block, roundKeys))
        # print()
        # printMatrix(cipher_text[j])
        cipher_text[j] = transposeMatrix(cipher_text[j])
        cipher = convert_2D_to_1D(cipher_text[j])
        j+=1
        # printList(cipher)
        # cipher_text = matrixToBitVector(cipher_text)
        cipher = matrixToBitVector(cipher)
        # print('cipher ASCII', cipher)
    return cipher_text

# decrypt a cipher text
def decrypt(cipher_text, key):
    t1 = time.time()
    roundKeys = AES(key)
    t2 = time.time()
    print()
    print('Time taken to generate round keys: ', t2 - t1)
    while(len(cipher_text) % (aes_len//8) != 0):
        cipher_text += ' '
    # print('len of cipher text:', len(cipher_text))
    plain_text = []
    j=0
    for i in range(0, len(cipher_text), aes_len//8):
        block = cipher_text[i:i+aes_len//8]
        # convert cipher text to bit vector
        block = asciiToBitVector(block)
        # decrypt cipher text
        plain_text.append(decryptBlock(block, roundKeys))
        # print()
        # printMatrix(plain_text[j])
        plain_text[j] = transposeMatrix(plain_text[j])
        plain = convert_2D_to_1D(plain_text[j])
        j+=1
        # printList(plain)
        plain = matrixToBitVector(plain)
        # print('plain ASCII', plain)
    return plain_text

def main():
    plain_text = 'Can They Do This To Us?'
    key = 'BUET CSE18 BatchBUET CSE18 Batch'

    t1 = time.time()
    print('Plain Text:  [In ASCII]', plain_text)
    print('[In Hex]', end=" ")
    pl = asciiToHex(plain_text)
    print(pl)
    
    cipher_text = encrypt(plain_text, key)
    t3 = time.time()
    print('Cipher Text: [In ASCII]', end=" ")
    for i in range(len(cipher_text)):
        ciph = convert_2D_to_1D(cipher_text[i])
        printArray(hexToAsciifromList(ciph))
    print()
    print('[In Hex]', end =" ")
    for i in range(len(cipher_text)):
        ciph = convert_2D_to_1D(cipher_text[i])
        printList(ciph)
    
    cipher_text = convert_to_string(cipher_text)
    # print(type(cipher_text))
    decipher_text = decrypt(cipher_text, key)
    t4 = time.time()
    print('Decipher Text: [In ASCII]', end=" ")
    for i in range(len(decipher_text)):
        deciph = convert_2D_to_1D(decipher_text[i])
        printArray(hexToAsciifromList(deciph))
    print()
    print('[In Hex]', end=" ")
    for i in range(len(decipher_text)):
        deciph = convert_2D_to_1D(decipher_text[i])
        printList(deciph)
    
    keysize = aes_len // 8
    key = key.strip()
    key = '0' * (keysize//8 - len(key)) if len(key) < keysize else key[:keysize]  
    print()
    print('Key:  [In ASCII]', key)
    print('[In Hex]', end =" ")
    key = asciiToHex(key)
    print(key)

    print('Time taken to encrypt: ', t3 - t1)
    print('Time taken to decrypt: ', t4 - t3)

if __name__ == '__main__':
    main()